"""The root query type which gives access points into the data universe."""
type Query implements Node {
  """
  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form.
  """
  query: Query!

  """
  The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.
  """
  nodeId: ID!

  """Fetches an object given its globally unique `ID`."""
  node(
    """The globally unique `ID`."""
    nodeId: ID!
  ): Node

  """Reads and enables pagination through a set of `Comment`."""
  comments(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Comment`."""
    orderBy: [CommentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CommentCondition

    """
    Indicates whether archived items should be included in the results or not.
    """
    includeArchived: IncludeArchivedOption = NO
  ): CommentsConnection

  """Reads and enables pagination through a set of `Image`."""
  images(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Image`."""
    orderBy: [ImagesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ImageCondition
  ): ImagesConnection

  """Reads and enables pagination through a set of `Location`."""
  locations(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Location`."""
    orderBy: [LocationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LocationCondition

    """
    Indicates whether archived items should be included in the results or not.
    """
    includeArchived: IncludeArchivedOption = NO
  ): LocationsConnection

  """Reads and enables pagination through a set of `Photo`."""
  photos(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Photo`."""
    orderBy: [PhotosOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PhotoCondition

    """
    Indicates whether archived items should be included in the results or not.
    """
    includeArchived: IncludeArchivedOption = NO
  ): PhotosConnection

  """Reads and enables pagination through a set of `PhotosLike`."""
  photosLikes(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `PhotosLike`."""
    orderBy: [PhotosLikesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PhotosLikeCondition
  ): PhotosLikesConnection

  """Reads and enables pagination through a set of `User`."""
  users(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserCondition

    """
    Indicates whether archived items should be included in the results or not.
    """
    includeArchived: IncludeArchivedOption = NO
  ): UsersConnection
  comment(id: Int!): Comment
  image(id: Int!): Image
  location(id: Int!): Location
  photo(id: Int!): Photo
  photosLike(id: Int!): PhotosLike
  photosLikeByIdAndPhotoId(id: Int!, photoId: Int!): PhotosLike
  photosLikeByUserIdAndPhotoId(userId: Int!, photoId: Int!): PhotosLike
  user(id: Int!): User
  currentUser: User
  currentUserId: Int

  """Reads and enables pagination through a set of `Location`."""
  locationsByDistance(
    lat: Float
    lng: Float

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor
  ): LocationsConnection

  """Reads a single `Comment` using its globally unique `ID`."""
  commentByNodeId(
    """The globally unique `ID` to be used in selecting a single `Comment`."""
    nodeId: ID!
  ): Comment

  """Reads a single `Image` using its globally unique `ID`."""
  imageByNodeId(
    """The globally unique `ID` to be used in selecting a single `Image`."""
    nodeId: ID!
  ): Image

  """Reads a single `Location` using its globally unique `ID`."""
  locationByNodeId(
    """The globally unique `ID` to be used in selecting a single `Location`."""
    nodeId: ID!
  ): Location

  """Reads a single `Photo` using its globally unique `ID`."""
  photoByNodeId(
    """The globally unique `ID` to be used in selecting a single `Photo`."""
    nodeId: ID!
  ): Photo

  """Reads a single `PhotosLike` using its globally unique `ID`."""
  photosLikeByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `PhotosLike`.
    """
    nodeId: ID!
  ): PhotosLike

  """Reads a single `User` using its globally unique `ID`."""
  userByNodeId(
    """The globally unique `ID` to be used in selecting a single `User`."""
    nodeId: ID!
  ): User
  locationBySlug(slug: String!): Location
}

"""An object with a globally unique `ID`."""
interface Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

"""A connection to a list of `Comment` values."""
type CommentsConnection {
  """A list of `Comment` objects."""
  nodes: [Comment!]!

  """
  A list of edges which contains the `Comment` and cursor to aid in pagination.
  """
  edges: [CommentsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Comment` you could get from the connection."""
  totalCount: Int!
}

type Comment implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  userId: Int!
  body: String!
  createdAt: Datetime!
  updatedAt: Datetime!
  photoId: Int!
  isArchived: Boolean!
  archivedAt: Datetime

  """Reads a single `User` that is related to this `Comment`."""
  user: User

  """Reads a single `Photo` that is related to this `Comment`."""
  photo: Photo
}

"""
A point in time as described by the [ISO
8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
"""
scalar Datetime

type User implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  displayName: String!
  pictureUrl: String
  createdAt: Datetime!
  updatedAt: Datetime!
  role: Role!
  isArchived: Boolean!
  archivedAt: Datetime

  """Reads and enables pagination through a set of `Image`."""
  images(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Image`."""
    orderBy: [ImagesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ImageCondition
  ): ImagesConnection!

  """Reads and enables pagination through a set of `Photo`."""
  authoredPhotos(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Photo`."""
    orderBy: [PhotosOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PhotoCondition

    """
    Indicates whether archived items should be included in the results or not.
    """
    includeArchived: IncludeArchivedOption = INHERIT
  ): PhotosConnection!

  """Reads and enables pagination through a set of `PhotosLike`."""
  photosLikes(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `PhotosLike`."""
    orderBy: [PhotosLikesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PhotosLikeCondition
  ): PhotosLikesConnection!

  """Reads and enables pagination through a set of `Comment`."""
  comments(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Comment`."""
    orderBy: [CommentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CommentCondition

    """
    Indicates whether archived items should be included in the results or not.
    """
    includeArchived: IncludeArchivedOption = INHERIT
  ): CommentsConnection!
}

enum Role {
  APP_USER
  APP_ADMIN
}

"""A connection to a list of `Image` values."""
type ImagesConnection {
  """A list of `Image` objects."""
  nodes: [Image!]!

  """
  A list of edges which contains the `Image` and cursor to aid in pagination.
  """
  edges: [ImagesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Image` you could get from the connection."""
  totalCount: Int!
}

type Image implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  createdAt: Datetime!
  updatedAt: Datetime!
  userId: Int!
  s3Bucket: String!
  s3Key: String!
  isHdr: Boolean!
  isUploaded: Boolean!
  exifData: JSON
  sources: [ImageSource]!

  """Reads a single `User` that is related to this `Image`."""
  user: User

  """Reads and enables pagination through a set of `Photo`."""
  photos(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Photo`."""
    orderBy: [PhotosOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PhotoCondition

    """
    Indicates whether archived items should be included in the results or not.
    """
    includeArchived: IncludeArchivedOption = NO
  ): PhotosConnection!
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

type ImageSource {
  s3Key: String
  size: Int
  type: String
}

"""A connection to a list of `Photo` values."""
type PhotosConnection {
  """A list of `Photo` objects."""
  nodes: [Photo!]!

  """
  A list of edges which contains the `Photo` and cursor to aid in pagination.
  """
  edges: [PhotosEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Photo` you could get from the connection."""
  totalCount: Int!
}

type Photo implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!

  """ @hasDefault"""
  authorId: Int
  url: String!
  thumbnail: Base64EncodedBinary
  locationId: Int!
  width: Int!
  height: Int!
  lat: Float
  lng: Float
  camera: String
  lens: String
  focalLength: String
  iso: Int
  shutterSpeed: Float
  aperture: String
  createdAt: Datetime!
  updatedAt: Datetime!
  shotAt: Datetime
  blurhash: String
  imageId: Int
  likesCount: Int!
  isArchived: Boolean!
  archivedAt: Datetime

  """Reads a single `User` that is related to this `Photo`."""
  author: User

  """Reads a single `Location` that is related to this `Photo`."""
  location: Location

  """Reads a single `Image` that is related to this `Photo`."""
  image: Image

  """Reads and enables pagination through a set of `PhotosLike`."""
  likes(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `PhotosLike`."""
    orderBy: [PhotosLikesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PhotosLikeCondition
  ): PhotosLikesConnection!

  """Reads and enables pagination through a set of `Comment`."""
  comments(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Comment`."""
    orderBy: [CommentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CommentCondition

    """
    Indicates whether archived items should be included in the results or not.
    """
    includeArchived: IncludeArchivedOption = INHERIT
  ): CommentsConnection!
}

"""Binary data encoded using Base64"""
scalar Base64EncodedBinary

type Location implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  name: String!
  updatedAt: Datetime!
  createdAt: Datetime!
  geo: Point!
  slug: String!
  description: String
  isArchived: Boolean!
  archivedAt: Datetime

  """Reads and enables pagination through a set of `Photo`."""
  photos(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Photo`."""
    orderBy: [PhotosOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PhotoCondition

    """
    Indicates whether archived items should be included in the results or not.
    """
    includeArchived: IncludeArchivedOption = INHERIT
  ): PhotosConnection!
}

type Point {
  x: Float!
  y: Float!
}

"""A location in a connection that can be used for resuming pagination."""
scalar Cursor

"""Methods to use when ordering `Photo`."""
enum PhotosOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  AUTHOR_ID_ASC
  AUTHOR_ID_DESC
  URL_ASC
  URL_DESC
  THUMBNAIL_ASC
  THUMBNAIL_DESC
  LOCATION_ID_ASC
  LOCATION_ID_DESC
  WIDTH_ASC
  WIDTH_DESC
  HEIGHT_ASC
  HEIGHT_DESC
  LAT_ASC
  LAT_DESC
  LNG_ASC
  LNG_DESC
  CAMERA_ASC
  CAMERA_DESC
  LENS_ASC
  LENS_DESC
  FOCAL_LENGTH_ASC
  FOCAL_LENGTH_DESC
  ISO_ASC
  ISO_DESC
  SHUTTER_SPEED_ASC
  SHUTTER_SPEED_DESC
  APERTURE_ASC
  APERTURE_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  SHOT_AT_ASC
  SHOT_AT_DESC
  BLURHASH_ASC
  BLURHASH_DESC
  IMAGE_ID_ASC
  IMAGE_ID_DESC
  LIKES_COUNT_ASC
  LIKES_COUNT_DESC
  IS_ARCHIVED_ASC
  IS_ARCHIVED_DESC
  ARCHIVED_AT_ASC
  ARCHIVED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Photo` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input PhotoCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `authorId` field."""
  authorId: Int

  """Checks for equality with the object’s `url` field."""
  url: String

  """Checks for equality with the object’s `thumbnail` field."""
  thumbnail: Base64EncodedBinary

  """Checks for equality with the object’s `locationId` field."""
  locationId: Int

  """Checks for equality with the object’s `width` field."""
  width: Int

  """Checks for equality with the object’s `height` field."""
  height: Int

  """Checks for equality with the object’s `lat` field."""
  lat: Float

  """Checks for equality with the object’s `lng` field."""
  lng: Float

  """Checks for equality with the object’s `camera` field."""
  camera: String

  """Checks for equality with the object’s `lens` field."""
  lens: String

  """Checks for equality with the object’s `focalLength` field."""
  focalLength: String

  """Checks for equality with the object’s `iso` field."""
  iso: Int

  """Checks for equality with the object’s `shutterSpeed` field."""
  shutterSpeed: Float

  """Checks for equality with the object’s `aperture` field."""
  aperture: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `shotAt` field."""
  shotAt: Datetime

  """Checks for equality with the object’s `blurhash` field."""
  blurhash: String

  """Checks for equality with the object’s `imageId` field."""
  imageId: Int

  """Checks for equality with the object’s `likesCount` field."""
  likesCount: Int

  """Checks for equality with the object’s `isArchived` field."""
  isArchived: Boolean

  """Checks for equality with the object’s `archivedAt` field."""
  archivedAt: Datetime
}

"""
Indicates whether archived items should be included in the results or not.
"""
enum IncludeArchivedOption {
  """Exclude archived items."""
  NO

  """Include archived items."""
  YES

  """Only include archived items (i.e. exclude non-archived items)."""
  EXCLUSIVELY

  """
  If there is a parent GraphQL record and it is archived then this is equivalent to YES, in all other cases this is equivalent to NO.
  """
  INHERIT
}

"""A connection to a list of `PhotosLike` values."""
type PhotosLikesConnection {
  """A list of `PhotosLike` objects."""
  nodes: [PhotosLike!]!

  """
  A list of edges which contains the `PhotosLike` and cursor to aid in pagination.
  """
  edges: [PhotosLikesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `PhotosLike` you could get from the connection."""
  totalCount: Int!
}

type PhotosLike implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  photoId: Int!
  userId: Int!
  createdAt: Datetime!
  updatedAt: Datetime!
  count: Int!

  """Reads a single `Photo` that is related to this `PhotosLike`."""
  photo: Photo

  """Reads a single `User` that is related to this `PhotosLike`."""
  user: User
}

"""A `PhotosLike` edge in the connection."""
type PhotosLikesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `PhotosLike` at the end of the edge."""
  node: PhotosLike!
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor

  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}

"""Methods to use when ordering `PhotosLike`."""
enum PhotosLikesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  PHOTO_ID_ASC
  PHOTO_ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  COUNT_ASC
  COUNT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `PhotosLike` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input PhotosLikeCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `photoId` field."""
  photoId: Int

  """Checks for equality with the object’s `userId` field."""
  userId: Int

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `count` field."""
  count: Int
}

"""Methods to use when ordering `Comment`."""
enum CommentsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  BODY_ASC
  BODY_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PHOTO_ID_ASC
  PHOTO_ID_DESC
  IS_ARCHIVED_ASC
  IS_ARCHIVED_DESC
  ARCHIVED_AT_ASC
  ARCHIVED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Comment` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input CommentCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `userId` field."""
  userId: Int

  """Checks for equality with the object’s `body` field."""
  body: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `photoId` field."""
  photoId: Int

  """Checks for equality with the object’s `isArchived` field."""
  isArchived: Boolean

  """Checks for equality with the object’s `archivedAt` field."""
  archivedAt: Datetime
}

"""A `Photo` edge in the connection."""
type PhotosEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Photo` at the end of the edge."""
  node: Photo!
}

"""A `Image` edge in the connection."""
type ImagesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Image` at the end of the edge."""
  node: Image!
}

"""Methods to use when ordering `Image`."""
enum ImagesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  USER_ID_ASC
  USER_ID_DESC
  S3_BUCKET_ASC
  S3_BUCKET_DESC
  S3_KEY_ASC
  S3_KEY_DESC
  IS_HDR_ASC
  IS_HDR_DESC
  IS_UPLOADED_ASC
  IS_UPLOADED_DESC
  EXIF_DATA_ASC
  EXIF_DATA_DESC
  SOURCES_ASC
  SOURCES_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Image` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input ImageCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `userId` field."""
  userId: Int

  """Checks for equality with the object’s `s3Bucket` field."""
  s3Bucket: String

  """Checks for equality with the object’s `s3Key` field."""
  s3Key: String

  """Checks for equality with the object’s `isHdr` field."""
  isHdr: Boolean

  """Checks for equality with the object’s `isUploaded` field."""
  isUploaded: Boolean

  """Checks for equality with the object’s `exifData` field."""
  exifData: JSON

  """Checks for equality with the object’s `sources` field."""
  sources: [ImageSourceInput]
}

"""An input for mutations affecting `ImageSource`"""
input ImageSourceInput {
  s3Key: String
  size: Int
  type: String
}

"""A `Comment` edge in the connection."""
type CommentsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Comment` at the end of the edge."""
  node: Comment!
}

"""A connection to a list of `Location` values."""
type LocationsConnection {
  """A list of `Location` objects."""
  nodes: [Location!]!

  """
  A list of edges which contains the `Location` and cursor to aid in pagination.
  """
  edges: [LocationsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Location` you could get from the connection."""
  totalCount: Int!
}

"""A `Location` edge in the connection."""
type LocationsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Location` at the end of the edge."""
  node: Location!
}

"""Methods to use when ordering `Location`."""
enum LocationsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  GEO_ASC
  GEO_DESC
  SLUG_ASC
  SLUG_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  IS_ARCHIVED_ASC
  IS_ARCHIVED_DESC
  ARCHIVED_AT_ASC
  ARCHIVED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Location` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input LocationCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `geo` field."""
  geo: PointInput

  """Checks for equality with the object’s `slug` field."""
  slug: String

  """Checks for equality with the object’s `description` field."""
  description: String

  """Checks for equality with the object’s `isArchived` field."""
  isArchived: Boolean

  """Checks for equality with the object’s `archivedAt` field."""
  archivedAt: Datetime
}

input PointInput {
  x: Float!
  y: Float!
}

"""A connection to a list of `User` values."""
type UsersConnection {
  """A list of `User` objects."""
  nodes: [User!]!

  """
  A list of edges which contains the `User` and cursor to aid in pagination.
  """
  edges: [UsersEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!
}

"""A `User` edge in the connection."""
type UsersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `User` at the end of the edge."""
  node: User!
}

"""Methods to use when ordering `User`."""
enum UsersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  DISPLAY_NAME_ASC
  DISPLAY_NAME_DESC
  PICTURE_URL_ASC
  PICTURE_URL_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  ROLE_ASC
  ROLE_DESC
  IS_ARCHIVED_ASC
  IS_ARCHIVED_DESC
  ARCHIVED_AT_ASC
  ARCHIVED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input UserCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `displayName` field."""
  displayName: String

  """Checks for equality with the object’s `pictureUrl` field."""
  pictureUrl: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `role` field."""
  role: Role

  """Checks for equality with the object’s `isArchived` field."""
  isArchived: Boolean

  """Checks for equality with the object’s `archivedAt` field."""
  archivedAt: Datetime
}

"""
The root mutation type which contains root level fields which mutate data.
"""
type Mutation {
  """Creates a single `Comment`."""
  createComment(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCommentInput!
  ): CreateCommentPayload

  """Creates a single `Image`."""
  createImage(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateImageInput!
  ): CreateImagePayload

  """Creates a single `Location`."""
  createLocation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateLocationInput!
  ): CreateLocationPayload

  """Creates a single `Photo`."""
  createPhoto(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreatePhotoInput!
  ): CreatePhotoPayload

  """Creates a single `PhotosLike`."""
  createPhotosLike(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreatePhotosLikeInput!
  ): CreatePhotosLikePayload

  """Creates a single `User`."""
  createUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateUserInput!
  ): CreateUserPayload

  """Updates a single `Comment` using its globally unique id and a patch."""
  updateCommentByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCommentByNodeIdInput!
  ): UpdateCommentPayload

  """Updates a single `Comment` using a unique key and a patch."""
  updateComment(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCommentInput!
  ): UpdateCommentPayload

  """Updates a single `Image` using its globally unique id and a patch."""
  updateImageByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateImageByNodeIdInput!
  ): UpdateImagePayload

  """Updates a single `Image` using a unique key and a patch."""
  updateImage(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateImageInput!
  ): UpdateImagePayload

  """Updates a single `Location` using its globally unique id and a patch."""
  updateLocationByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateLocationByNodeIdInput!
  ): UpdateLocationPayload

  """Updates a single `Location` using a unique key and a patch."""
  updateLocation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateLocationInput!
  ): UpdateLocationPayload

  """Updates a single `Photo` using its globally unique id and a patch."""
  updatePhotoByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePhotoByNodeIdInput!
  ): UpdatePhotoPayload

  """Updates a single `Photo` using a unique key and a patch."""
  updatePhoto(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePhotoInput!
  ): UpdatePhotoPayload

  """
  Updates a single `PhotosLike` using its globally unique id and a patch.
  """
  updatePhotosLikeByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePhotosLikeByNodeIdInput!
  ): UpdatePhotosLikePayload

  """Updates a single `PhotosLike` using a unique key and a patch."""
  updatePhotosLike(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePhotosLikeInput!
  ): UpdatePhotosLikePayload

  """Updates a single `PhotosLike` using a unique key and a patch."""
  updatePhotosLikeByIdAndPhotoId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePhotosLikeByIdAndPhotoIdInput!
  ): UpdatePhotosLikePayload

  """Updates a single `PhotosLike` using a unique key and a patch."""
  updatePhotosLikeByUserIdAndPhotoId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePhotosLikeByUserIdAndPhotoIdInput!
  ): UpdatePhotosLikePayload

  """Updates a single `User` using its globally unique id and a patch."""
  updateUserByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserByNodeIdInput!
  ): UpdateUserPayload

  """Updates a single `User` using a unique key and a patch."""
  updateUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserInput!
  ): UpdateUserPayload

  """Deletes a single `Comment` using its globally unique id."""
  deleteCommentByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCommentByNodeIdInput!
  ): DeleteCommentPayload

  """Deletes a single `Comment` using a unique key."""
  deleteComment(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCommentInput!
  ): DeleteCommentPayload

  """Deletes a single `Image` using its globally unique id."""
  deleteImageByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteImageByNodeIdInput!
  ): DeleteImagePayload

  """Deletes a single `Image` using a unique key."""
  deleteImage(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteImageInput!
  ): DeleteImagePayload

  """Deletes a single `Location` using its globally unique id."""
  deleteLocationByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteLocationByNodeIdInput!
  ): DeleteLocationPayload

  """Deletes a single `Location` using a unique key."""
  deleteLocation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteLocationInput!
  ): DeleteLocationPayload

  """Deletes a single `Photo` using its globally unique id."""
  deletePhotoByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePhotoByNodeIdInput!
  ): DeletePhotoPayload

  """Deletes a single `Photo` using a unique key."""
  deletePhoto(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePhotoInput!
  ): DeletePhotoPayload

  """Deletes a single `PhotosLike` using its globally unique id."""
  deletePhotosLikeByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePhotosLikeByNodeIdInput!
  ): DeletePhotosLikePayload

  """Deletes a single `PhotosLike` using a unique key."""
  deletePhotosLike(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePhotosLikeInput!
  ): DeletePhotosLikePayload

  """Deletes a single `PhotosLike` using a unique key."""
  deletePhotosLikeByIdAndPhotoId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePhotosLikeByIdAndPhotoIdInput!
  ): DeletePhotosLikePayload

  """Deletes a single `PhotosLike` using a unique key."""
  deletePhotosLikeByUserIdAndPhotoId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePhotosLikeByUserIdAndPhotoIdInput!
  ): DeletePhotosLikePayload

  """Deletes a single `User` using its globally unique id."""
  deleteUserByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUserByNodeIdInput!
  ): DeleteUserPayload

  """Deletes a single `User` using a unique key."""
  deleteUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUserInput!
  ): DeleteUserPayload
  dropAllPolicies(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DropAllPoliciesInput!
  ): DropAllPoliciesPayload
  upsertPhotoLike(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertPhotoLikeInput!
  ): UpsertPhotoLikePayload
  createImageUpload(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateImageUploadInput!
  ): CreateImageUploadPayload!
  loginWithGoogle(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: LoginWithGoogleInput!
  ): LoginWithGooglePayload!
  getAccessToken(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: GetAccessTokenInput!
  ): GetAccessTokenPayload!
  logout(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: LogoutInput!
  ): Boolean!
}

"""The output of our create `Comment` mutation."""
type CreateCommentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Comment` that was created by this mutation."""
  comment: Comment

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Comment`."""
  user: User

  """Reads a single `Photo` that is related to this `Comment`."""
  photo: Photo

  """An edge for our `Comment`. May be used by Relay 1."""
  commentEdge(
    """The method to use when ordering `Comment`."""
    orderBy: [CommentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CommentsEdge
}

"""All input for the create `Comment` mutation."""
input CreateCommentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Comment` to be created by this mutation."""
  comment: CommentInput!
}

"""An input for mutations affecting `Comment`"""
input CommentInput {
  id: Int
  body: String!
  createdAt: Datetime
  updatedAt: Datetime
  photoId: Int!
  isArchived: Boolean
  archivedAt: Datetime
}

"""The output of our create `Image` mutation."""
type CreateImagePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Image` that was created by this mutation."""
  image: Image

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Image`."""
  user: User

  """An edge for our `Image`. May be used by Relay 1."""
  imageEdge(
    """The method to use when ordering `Image`."""
    orderBy: [ImagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ImagesEdge
}

"""All input for the create `Image` mutation."""
input CreateImageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Image` to be created by this mutation."""
  image: ImageInput!
}

"""An input for mutations affecting `Image`"""
input ImageInput {
  id: Int
  createdAt: Datetime
  updatedAt: Datetime
  userId: Int
  s3Bucket: String!
  s3Key: String!
  isHdr: Boolean
  isUploaded: Boolean
  exifData: JSON
  sources: [ImageSourceInput]
}

"""The output of our create `Location` mutation."""
type CreateLocationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Location` that was created by this mutation."""
  location: Location

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Location`. May be used by Relay 1."""
  locationEdge(
    """The method to use when ordering `Location`."""
    orderBy: [LocationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): LocationsEdge
}

"""All input for the create `Location` mutation."""
input CreateLocationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Location` to be created by this mutation."""
  location: LocationInput!
}

"""An input for mutations affecting `Location`"""
input LocationInput {
  id: Int
  name: String!
  updatedAt: Datetime
  createdAt: Datetime
  geo: PointInput
  slug: String
  description: String
  isArchived: Boolean
  archivedAt: Datetime
}

"""The output of our create `Photo` mutation."""
type CreatePhotoPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Photo` that was created by this mutation."""
  photo: Photo

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Photo`."""
  author: User

  """Reads a single `Location` that is related to this `Photo`."""
  location: Location

  """Reads a single `Image` that is related to this `Photo`."""
  image: Image

  """An edge for our `Photo`. May be used by Relay 1."""
  photoEdge(
    """The method to use when ordering `Photo`."""
    orderBy: [PhotosOrderBy!] = [PRIMARY_KEY_ASC]
  ): PhotosEdge
}

"""All input for the create `Photo` mutation."""
input CreatePhotoInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Photo` to be created by this mutation."""
  photo: PhotoInput!
}

"""An input for mutations affecting `Photo`"""
input PhotoInput {
  id: Int
  url: String!
  thumbnail: Base64EncodedBinary
  locationId: Int!
  width: Int!
  height: Int!
  lat: Float
  lng: Float
  camera: String
  lens: String
  focalLength: String
  iso: Int
  shutterSpeed: Float
  aperture: String
  createdAt: Datetime
  updatedAt: Datetime
  shotAt: Datetime
  blurhash: String
  imageId: Int
  likesCount: Int
  isArchived: Boolean
  archivedAt: Datetime
}

"""The output of our create `PhotosLike` mutation."""
type CreatePhotosLikePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `PhotosLike` that was created by this mutation."""
  photosLike: PhotosLike

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Photo` that is related to this `PhotosLike`."""
  photo: Photo

  """Reads a single `User` that is related to this `PhotosLike`."""
  user: User

  """An edge for our `PhotosLike`. May be used by Relay 1."""
  photosLikeEdge(
    """The method to use when ordering `PhotosLike`."""
    orderBy: [PhotosLikesOrderBy!] = [PRIMARY_KEY_ASC]
  ): PhotosLikesEdge
}

"""All input for the create `PhotosLike` mutation."""
input CreatePhotosLikeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `PhotosLike` to be created by this mutation."""
  photosLike: PhotosLikeInput!
}

"""An input for mutations affecting `PhotosLike`"""
input PhotosLikeInput {
  id: Int
  photoId: Int!
  userId: Int
  createdAt: Datetime
  updatedAt: Datetime
  count: Int
}

"""The output of our create `User` mutation."""
type CreateUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `User` that was created by this mutation."""
  user: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

"""All input for the create `User` mutation."""
input CreateUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `User` to be created by this mutation."""
  user: UserInput!
}

"""An input for mutations affecting `User`"""
input UserInput {
  id: Int
  displayName: String!
  pictureUrl: String
  createdAt: Datetime
  updatedAt: Datetime
  role: Role
  isArchived: Boolean
  archivedAt: Datetime
}

"""The output of our update `Comment` mutation."""
type UpdateCommentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Comment` that was updated by this mutation."""
  comment: Comment

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Comment`."""
  user: User

  """Reads a single `Photo` that is related to this `Comment`."""
  photo: Photo

  """An edge for our `Comment`. May be used by Relay 1."""
  commentEdge(
    """The method to use when ordering `Comment`."""
    orderBy: [CommentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CommentsEdge
}

"""All input for the `updateCommentByNodeId` mutation."""
input UpdateCommentByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Comment` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Comment` being updated.
  """
  patch: CommentPatch!
}

"""
Represents an update to a `Comment`. Fields that are set will be updated.
"""
input CommentPatch {
  id: Int
  userId: Int
  body: String
  createdAt: Datetime
  updatedAt: Datetime
  photoId: Int
  isArchived: Boolean
  archivedAt: Datetime
}

"""All input for the `updateComment` mutation."""
input UpdateCommentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Comment` being updated.
  """
  patch: CommentPatch!
  id: Int!
}

"""The output of our update `Image` mutation."""
type UpdateImagePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Image` that was updated by this mutation."""
  image: Image

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Image`."""
  user: User

  """An edge for our `Image`. May be used by Relay 1."""
  imageEdge(
    """The method to use when ordering `Image`."""
    orderBy: [ImagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ImagesEdge
}

"""All input for the `updateImageByNodeId` mutation."""
input UpdateImageByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Image` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Image` being updated.
  """
  patch: ImagePatch!
}

"""
Represents an update to a `Image`. Fields that are set will be updated.
"""
input ImagePatch {
  id: Int
  createdAt: Datetime
  updatedAt: Datetime
  userId: Int
  s3Bucket: String
  s3Key: String
  isHdr: Boolean
  isUploaded: Boolean
  exifData: JSON
  sources: [ImageSourceInput]
}

"""All input for the `updateImage` mutation."""
input UpdateImageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Image` being updated.
  """
  patch: ImagePatch!
  id: Int!
}

"""The output of our update `Location` mutation."""
type UpdateLocationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Location` that was updated by this mutation."""
  location: Location

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Location`. May be used by Relay 1."""
  locationEdge(
    """The method to use when ordering `Location`."""
    orderBy: [LocationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): LocationsEdge
}

"""All input for the `updateLocationByNodeId` mutation."""
input UpdateLocationByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Location` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Location` being updated.
  """
  patch: LocationPatch!
}

"""
Represents an update to a `Location`. Fields that are set will be updated.
"""
input LocationPatch {
  id: Int
  name: String
  updatedAt: Datetime
  createdAt: Datetime
  geo: PointInput
  slug: String
  description: String
  isArchived: Boolean
  archivedAt: Datetime
}

"""All input for the `updateLocation` mutation."""
input UpdateLocationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Location` being updated.
  """
  patch: LocationPatch!
  id: Int!
}

"""The output of our update `Photo` mutation."""
type UpdatePhotoPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Photo` that was updated by this mutation."""
  photo: Photo

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Photo`."""
  author: User

  """Reads a single `Location` that is related to this `Photo`."""
  location: Location

  """Reads a single `Image` that is related to this `Photo`."""
  image: Image

  """An edge for our `Photo`. May be used by Relay 1."""
  photoEdge(
    """The method to use when ordering `Photo`."""
    orderBy: [PhotosOrderBy!] = [PRIMARY_KEY_ASC]
  ): PhotosEdge
}

"""All input for the `updatePhotoByNodeId` mutation."""
input UpdatePhotoByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Photo` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Photo` being updated.
  """
  patch: PhotoPatch!
}

"""
Represents an update to a `Photo`. Fields that are set will be updated.
"""
input PhotoPatch {
  id: Int
  url: String
  thumbnail: Base64EncodedBinary
  locationId: Int
  width: Int
  height: Int
  lat: Float
  lng: Float
  camera: String
  lens: String
  focalLength: String
  iso: Int
  shutterSpeed: Float
  aperture: String
  createdAt: Datetime
  updatedAt: Datetime
  shotAt: Datetime
  blurhash: String
  imageId: Int
  likesCount: Int
  isArchived: Boolean
  archivedAt: Datetime
}

"""All input for the `updatePhoto` mutation."""
input UpdatePhotoInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Photo` being updated.
  """
  patch: PhotoPatch!
  id: Int!
}

"""The output of our update `PhotosLike` mutation."""
type UpdatePhotosLikePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `PhotosLike` that was updated by this mutation."""
  photosLike: PhotosLike

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Photo` that is related to this `PhotosLike`."""
  photo: Photo

  """Reads a single `User` that is related to this `PhotosLike`."""
  user: User

  """An edge for our `PhotosLike`. May be used by Relay 1."""
  photosLikeEdge(
    """The method to use when ordering `PhotosLike`."""
    orderBy: [PhotosLikesOrderBy!] = [PRIMARY_KEY_ASC]
  ): PhotosLikesEdge
}

"""All input for the `updatePhotosLikeByNodeId` mutation."""
input UpdatePhotosLikeByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `PhotosLike` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `PhotosLike` being updated.
  """
  patch: PhotosLikePatch!
}

"""
Represents an update to a `PhotosLike`. Fields that are set will be updated.
"""
input PhotosLikePatch {
  id: Int
  photoId: Int
  userId: Int
  createdAt: Datetime
  updatedAt: Datetime
  count: Int
}

"""All input for the `updatePhotosLike` mutation."""
input UpdatePhotosLikeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `PhotosLike` being updated.
  """
  patch: PhotosLikePatch!
  id: Int!
}

"""All input for the `updatePhotosLikeByIdAndPhotoId` mutation."""
input UpdatePhotosLikeByIdAndPhotoIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `PhotosLike` being updated.
  """
  patch: PhotosLikePatch!
  id: Int!
  photoId: Int!
}

"""All input for the `updatePhotosLikeByUserIdAndPhotoId` mutation."""
input UpdatePhotosLikeByUserIdAndPhotoIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `PhotosLike` being updated.
  """
  patch: PhotosLikePatch!
  userId: Int!
  photoId: Int!
}

"""The output of our update `User` mutation."""
type UpdateUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `User` that was updated by this mutation."""
  user: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

"""All input for the `updateUserByNodeId` mutation."""
input UpdateUserByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `User` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `User` being updated.
  """
  patch: UserPatch!
}

"""Represents an update to a `User`. Fields that are set will be updated."""
input UserPatch {
  id: Int
  displayName: String
  pictureUrl: String
  createdAt: Datetime
  updatedAt: Datetime
  role: Role
  isArchived: Boolean
  archivedAt: Datetime
}

"""All input for the `updateUser` mutation."""
input UpdateUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `User` being updated.
  """
  patch: UserPatch!
  id: Int!
}

"""The output of our delete `Comment` mutation."""
type DeleteCommentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Comment` that was deleted by this mutation."""
  comment: Comment
  deletedCommentNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Comment`."""
  user: User

  """Reads a single `Photo` that is related to this `Comment`."""
  photo: Photo

  """An edge for our `Comment`. May be used by Relay 1."""
  commentEdge(
    """The method to use when ordering `Comment`."""
    orderBy: [CommentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CommentsEdge
}

"""All input for the `deleteCommentByNodeId` mutation."""
input DeleteCommentByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Comment` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteComment` mutation."""
input DeleteCommentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Image` mutation."""
type DeleteImagePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Image` that was deleted by this mutation."""
  image: Image
  deletedImageNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Image`."""
  user: User

  """An edge for our `Image`. May be used by Relay 1."""
  imageEdge(
    """The method to use when ordering `Image`."""
    orderBy: [ImagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ImagesEdge
}

"""All input for the `deleteImageByNodeId` mutation."""
input DeleteImageByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Image` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteImage` mutation."""
input DeleteImageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Location` mutation."""
type DeleteLocationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Location` that was deleted by this mutation."""
  location: Location
  deletedLocationNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Location`. May be used by Relay 1."""
  locationEdge(
    """The method to use when ordering `Location`."""
    orderBy: [LocationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): LocationsEdge
}

"""All input for the `deleteLocationByNodeId` mutation."""
input DeleteLocationByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Location` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteLocation` mutation."""
input DeleteLocationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Photo` mutation."""
type DeletePhotoPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Photo` that was deleted by this mutation."""
  photo: Photo
  deletedPhotoNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Photo`."""
  author: User

  """Reads a single `Location` that is related to this `Photo`."""
  location: Location

  """Reads a single `Image` that is related to this `Photo`."""
  image: Image

  """An edge for our `Photo`. May be used by Relay 1."""
  photoEdge(
    """The method to use when ordering `Photo`."""
    orderBy: [PhotosOrderBy!] = [PRIMARY_KEY_ASC]
  ): PhotosEdge
}

"""All input for the `deletePhotoByNodeId` mutation."""
input DeletePhotoByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Photo` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deletePhoto` mutation."""
input DeletePhotoInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `PhotosLike` mutation."""
type DeletePhotosLikePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `PhotosLike` that was deleted by this mutation."""
  photosLike: PhotosLike
  deletedPhotosLikeNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Photo` that is related to this `PhotosLike`."""
  photo: Photo

  """Reads a single `User` that is related to this `PhotosLike`."""
  user: User

  """An edge for our `PhotosLike`. May be used by Relay 1."""
  photosLikeEdge(
    """The method to use when ordering `PhotosLike`."""
    orderBy: [PhotosLikesOrderBy!] = [PRIMARY_KEY_ASC]
  ): PhotosLikesEdge
}

"""All input for the `deletePhotosLikeByNodeId` mutation."""
input DeletePhotosLikeByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `PhotosLike` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deletePhotosLike` mutation."""
input DeletePhotosLikeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""All input for the `deletePhotosLikeByIdAndPhotoId` mutation."""
input DeletePhotosLikeByIdAndPhotoIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
  photoId: Int!
}

"""All input for the `deletePhotosLikeByUserIdAndPhotoId` mutation."""
input DeletePhotosLikeByUserIdAndPhotoIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  userId: Int!
  photoId: Int!
}

"""The output of our delete `User` mutation."""
type DeleteUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `User` that was deleted by this mutation."""
  user: User
  deletedUserNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

"""All input for the `deleteUserByNodeId` mutation."""
input DeleteUserByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `User` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteUser` mutation."""
input DeleteUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our `dropAllPolicies` mutation."""
type DropAllPoliciesPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `dropAllPolicies` mutation."""
input DropAllPoliciesInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  tableNameIn: String
  schemaNameIn: String
}

"""The output of our `upsertPhotoLike` mutation."""
type UpsertPhotoLikePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  photosLike: PhotosLike

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Photo` that is related to this `PhotosLike`."""
  photo: Photo

  """Reads a single `User` that is related to this `PhotosLike`."""
  user: User

  """An edge for our `PhotosLike`. May be used by Relay 1."""
  photosLikeEdge(
    """The method to use when ordering `PhotosLike`."""
    orderBy: [PhotosLikesOrderBy!] = [PRIMARY_KEY_ASC]
  ): PhotosLikesEdge
}

"""All input for the `upsertPhotoLike` mutation."""
input UpsertPhotoLikeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  photoid: Int
  count: Int
}

type CreateImageUploadPayload {
  url: String!
  fields: JSON!
  image: Image!
}

input CreateImageUploadInput {
  contentType: String!
}

type LoginWithGooglePayload {
  accessToken: JwtToken!
  refreshToken: String
  user: User!
}

"""
A JSON Web Token defined by [RFC 7519](https://tools.ietf.org/html/rfc7519)
which securely represents claims between two parties.
"""
scalar JwtToken

input LoginWithGoogleInput {
  code: String!
  toCookie: Boolean
}

type GetAccessTokenPayload {
  accessToken: JwtToken!
}

input GetAccessTokenInput {
  refreshToken: String
  fromCookie: Boolean
}

input LogoutInput {
  refreshToken: String
  fromCookie: Boolean
}
